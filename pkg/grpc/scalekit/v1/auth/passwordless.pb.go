// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: scalekit/v1/auth/passwordless.proto

package auth

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "github.com/scalekit-inc/scalekit-sdk-go/v2/pkg/grpc/scalekit/v1/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TemplateType int32

const (
	TemplateType_UNSPECIFIED TemplateType = 0
	TemplateType_SIGNIN      TemplateType = 1
	TemplateType_SIGNUP      TemplateType = 2
)

// Enum value maps for TemplateType.
var (
	TemplateType_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "SIGNIN",
		2: "SIGNUP",
	}
	TemplateType_value = map[string]int32{
		"UNSPECIFIED": 0,
		"SIGNIN":      1,
		"SIGNUP":      2,
	}
)

func (x TemplateType) Enum() *TemplateType {
	p := new(TemplateType)
	*p = x
	return p
}

func (x TemplateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TemplateType) Descriptor() protoreflect.EnumDescriptor {
	return file_scalekit_v1_auth_passwordless_proto_enumTypes[0].Descriptor()
}

func (TemplateType) Type() protoreflect.EnumType {
	return &file_scalekit_v1_auth_passwordless_proto_enumTypes[0]
}

func (x TemplateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TemplateType.Descriptor instead.
func (TemplateType) EnumDescriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{0}
}

type PasswordlessType int32

const (
	PasswordlessType_PASSWORDLESS_TYPE_UNSPECIFIED PasswordlessType = 0
	PasswordlessType_OTP                           PasswordlessType = 1
	PasswordlessType_LINK                          PasswordlessType = 2
	PasswordlessType_LINK_OTP                      PasswordlessType = 3
)

// Enum value maps for PasswordlessType.
var (
	PasswordlessType_name = map[int32]string{
		0: "PASSWORDLESS_TYPE_UNSPECIFIED",
		1: "OTP",
		2: "LINK",
		3: "LINK_OTP",
	}
	PasswordlessType_value = map[string]int32{
		"PASSWORDLESS_TYPE_UNSPECIFIED": 0,
		"OTP":                           1,
		"LINK":                          2,
		"LINK_OTP":                      3,
	}
)

func (x PasswordlessType) Enum() *PasswordlessType {
	p := new(PasswordlessType)
	*p = x
	return p
}

func (x PasswordlessType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PasswordlessType) Descriptor() protoreflect.EnumDescriptor {
	return file_scalekit_v1_auth_passwordless_proto_enumTypes[1].Descriptor()
}

func (PasswordlessType) Type() protoreflect.EnumType {
	return &file_scalekit_v1_auth_passwordless_proto_enumTypes[1]
}

func (x PasswordlessType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PasswordlessType.Descriptor instead.
func (PasswordlessType) EnumDescriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{1}
}

type SendPasswordlessRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Email             string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Template          *TemplateType          `protobuf:"varint,2,opt,name=template,proto3,enum=scalekit.v1.auth.passwordless.TemplateType,oneof" json:"template,omitempty"`
	MagiclinkAuthUri  *string                `protobuf:"bytes,3,opt,name=magiclink_auth_uri,json=magiclinkAuthUri,proto3,oneof" json:"magiclink_auth_uri,omitempty"`
	State             *string                `protobuf:"bytes,4,opt,name=state,proto3,oneof" json:"state,omitempty"`
	ExpiresIn         *uint32                `protobuf:"varint,5,opt,name=expires_in,json=expiresIn,proto3,oneof" json:"expires_in,omitempty"`
	TemplateVariables map[string]string      `protobuf:"bytes,6,rep,name=template_variables,json=templateVariables,proto3" json:"template_variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SendPasswordlessRequest) Reset() {
	*x = SendPasswordlessRequest{}
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendPasswordlessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendPasswordlessRequest) ProtoMessage() {}

func (x *SendPasswordlessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendPasswordlessRequest.ProtoReflect.Descriptor instead.
func (*SendPasswordlessRequest) Descriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{0}
}

func (x *SendPasswordlessRequest) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *SendPasswordlessRequest) GetTemplate() TemplateType {
	if x != nil && x.Template != nil {
		return *x.Template
	}
	return TemplateType_UNSPECIFIED
}

func (x *SendPasswordlessRequest) GetMagiclinkAuthUri() string {
	if x != nil && x.MagiclinkAuthUri != nil {
		return *x.MagiclinkAuthUri
	}
	return ""
}

func (x *SendPasswordlessRequest) GetState() string {
	if x != nil && x.State != nil {
		return *x.State
	}
	return ""
}

func (x *SendPasswordlessRequest) GetExpiresIn() uint32 {
	if x != nil && x.ExpiresIn != nil {
		return *x.ExpiresIn
	}
	return 0
}

func (x *SendPasswordlessRequest) GetTemplateVariables() map[string]string {
	if x != nil {
		return x.TemplateVariables
	}
	return nil
}

type SendPasswordlessResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	AuthRequestId    string                 `protobuf:"bytes,1,opt,name=auth_request_id,json=authRequestId,proto3" json:"auth_request_id,omitempty"`
	ExpiresAt        int64                  `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	ExpiresIn        uint32                 `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	PasswordlessType PasswordlessType       `protobuf:"varint,4,opt,name=passwordless_type,json=passwordlessType,proto3,enum=scalekit.v1.auth.passwordless.PasswordlessType" json:"passwordless_type,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SendPasswordlessResponse) Reset() {
	*x = SendPasswordlessResponse{}
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendPasswordlessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendPasswordlessResponse) ProtoMessage() {}

func (x *SendPasswordlessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendPasswordlessResponse.ProtoReflect.Descriptor instead.
func (*SendPasswordlessResponse) Descriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{1}
}

func (x *SendPasswordlessResponse) GetAuthRequestId() string {
	if x != nil {
		return x.AuthRequestId
	}
	return ""
}

func (x *SendPasswordlessResponse) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *SendPasswordlessResponse) GetExpiresIn() uint32 {
	if x != nil {
		return x.ExpiresIn
	}
	return 0
}

func (x *SendPasswordlessResponse) GetPasswordlessType() PasswordlessType {
	if x != nil {
		return x.PasswordlessType
	}
	return PasswordlessType_PASSWORDLESS_TYPE_UNSPECIFIED
}

type VerifyPasswordLessRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to AuthCredential:
	//
	//	*VerifyPasswordLessRequest_Code
	//	*VerifyPasswordLessRequest_LinkToken
	AuthCredential isVerifyPasswordLessRequest_AuthCredential `protobuf_oneof:"auth_credential"`
	AuthRequestId  *string                                    `protobuf:"bytes,3,opt,name=auth_request_id,json=authRequestId,proto3,oneof" json:"auth_request_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VerifyPasswordLessRequest) Reset() {
	*x = VerifyPasswordLessRequest{}
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyPasswordLessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyPasswordLessRequest) ProtoMessage() {}

func (x *VerifyPasswordLessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyPasswordLessRequest.ProtoReflect.Descriptor instead.
func (*VerifyPasswordLessRequest) Descriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{2}
}

func (x *VerifyPasswordLessRequest) GetAuthCredential() isVerifyPasswordLessRequest_AuthCredential {
	if x != nil {
		return x.AuthCredential
	}
	return nil
}

func (x *VerifyPasswordLessRequest) GetCode() string {
	if x != nil {
		if x, ok := x.AuthCredential.(*VerifyPasswordLessRequest_Code); ok {
			return x.Code
		}
	}
	return ""
}

func (x *VerifyPasswordLessRequest) GetLinkToken() string {
	if x != nil {
		if x, ok := x.AuthCredential.(*VerifyPasswordLessRequest_LinkToken); ok {
			return x.LinkToken
		}
	}
	return ""
}

func (x *VerifyPasswordLessRequest) GetAuthRequestId() string {
	if x != nil && x.AuthRequestId != nil {
		return *x.AuthRequestId
	}
	return ""
}

type isVerifyPasswordLessRequest_AuthCredential interface {
	isVerifyPasswordLessRequest_AuthCredential()
}

type VerifyPasswordLessRequest_Code struct {
	Code string `protobuf:"bytes,1,opt,name=code,proto3,oneof"`
}

type VerifyPasswordLessRequest_LinkToken struct {
	LinkToken string `protobuf:"bytes,2,opt,name=link_token,json=linkToken,proto3,oneof"`
}

func (*VerifyPasswordLessRequest_Code) isVerifyPasswordLessRequest_AuthCredential() {}

func (*VerifyPasswordLessRequest_LinkToken) isVerifyPasswordLessRequest_AuthCredential() {}

type ResendPasswordlessRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AuthRequestId string                 `protobuf:"bytes,1,opt,name=auth_request_id,json=authRequestId,proto3" json:"auth_request_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResendPasswordlessRequest) Reset() {
	*x = ResendPasswordlessRequest{}
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResendPasswordlessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResendPasswordlessRequest) ProtoMessage() {}

func (x *ResendPasswordlessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResendPasswordlessRequest.ProtoReflect.Descriptor instead.
func (*ResendPasswordlessRequest) Descriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{3}
}

func (x *ResendPasswordlessRequest) GetAuthRequestId() string {
	if x != nil {
		return x.AuthRequestId
	}
	return ""
}

type VerifyPasswordLessResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Email            string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	State            *string                `protobuf:"bytes,2,opt,name=state,proto3,oneof" json:"state,omitempty"`
	Template         *TemplateType          `protobuf:"varint,3,opt,name=template,proto3,enum=scalekit.v1.auth.passwordless.TemplateType,oneof" json:"template,omitempty"`
	PasswordlessType PasswordlessType       `protobuf:"varint,4,opt,name=passwordless_type,json=passwordlessType,proto3,enum=scalekit.v1.auth.passwordless.PasswordlessType" json:"passwordless_type,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VerifyPasswordLessResponse) Reset() {
	*x = VerifyPasswordLessResponse{}
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyPasswordLessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyPasswordLessResponse) ProtoMessage() {}

func (x *VerifyPasswordLessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scalekit_v1_auth_passwordless_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyPasswordLessResponse.ProtoReflect.Descriptor instead.
func (*VerifyPasswordLessResponse) Descriptor() ([]byte, []int) {
	return file_scalekit_v1_auth_passwordless_proto_rawDescGZIP(), []int{4}
}

func (x *VerifyPasswordLessResponse) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *VerifyPasswordLessResponse) GetState() string {
	if x != nil && x.State != nil {
		return *x.State
	}
	return ""
}

func (x *VerifyPasswordLessResponse) GetTemplate() TemplateType {
	if x != nil && x.Template != nil {
		return *x.Template
	}
	return TemplateType_UNSPECIFIED
}

func (x *VerifyPasswordLessResponse) GetPasswordlessType() PasswordlessType {
	if x != nil {
		return x.PasswordlessType
	}
	return PasswordlessType_PASSWORDLESS_TYPE_UNSPECIFIED
}

var File_scalekit_v1_auth_passwordless_proto protoreflect.FileDescriptor

const file_scalekit_v1_auth_passwordless_proto_rawDesc = "" +
	"\n" +
	"#scalekit/v1/auth/passwordless.proto\x12\x1dscalekit.v1.auth.passwordless\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a!scalekit/v1/options/options.proto\"\xc8\x10\n" +
	"\x17SendPasswordlessRequest\x12\xad\x01\n" +
	"\x05email\x18\x01 \x01(\tB\x96\x01\x92A\x85\x012kEmail address where the passwordless authentication credentials will be sent. Must be a valid email format.J\x16\"john.doe@example.com\"\xbaH\n" +
	"\xc8\x01\x01r\x05\x10\x01\x18\xc0\x02R\x05email\x12\xa6\x02\n" +
	"\btemplate\x18\x02 \x01(\x0e2+.scalekit.v1.auth.passwordless.TemplateTypeB\xd7\x01\x92A\xcb\x012\xbe\x01Specifies the authentication intent for the passwordless request. Use SIGNIN for existing users or SIGNUP for new user registration. This affects the email template and user experience flow.J\b\"SIGNIN\"\xbaH\x05\x82\x01\x02\x10\x01H\x00R\btemplate\x88\x01\x01\x12\xa9\x02\n" +
	"\x12magiclink_auth_uri\x18\x03 \x01(\tB\xf5\x01\x92A\xe4\x012\xaf\x01Your application's callback URL where users will be redirected after clicking the magic link in their email. The link token will be appended as a query parameter as link_tokenJ0\"https://yourapp.com/auth/passwordless/callback\"\xe0A\x01\xbaH\ar\x05\x10\x01\x18\xe8\aH\x01R\x10magiclinkAuthUri\x88\x01\x01\x12\x9b\x02\n" +
	"\x05state\x18\x04 \x01(\tB\xff\x01\x92A\xee\x012\xd9\x01Custom state parameter that will be returned unchanged in the verification response. Use this to maintain application state between the authentication request and callback, such as the intended destination after loginJ\x10\"d62ivasry29lso\"\xe0A\x01\xbaH\ar\x05\x10\x01\x18\xe8\aH\x02R\x05state\x88\x01\x01\x12\xa6\x01\n" +
	"\n" +
	"expires_in\x18\x05 \x01(\rB\x81\x01\x92A{2tTime in seconds until the passwordless authentication expires. If not specified, defaults to 300 seconds (5 minutes)J\x03300\xe0A\x01H\x03R\texpiresIn\x88\x01\x01\x12\xdd\x05\n" +
	"\x12template_variables\x18\x06 \x03(\v2M.scalekit.v1.auth.passwordless.SendPasswordlessRequest.TemplateVariablesEntryB\xde\x04\x92A\xcf\x042\x9a\x04A set of key-value pairs to personalize the email template.\n" +
	"\n" +
	"* You may include up to 30 key-value pairs.\n" +
	"* The following variable names are reserved by the system and cannot be supplied: `otp`, `expiry_time_relative`, `link`, `expire_time`, `expiry_time`.\n" +
	"* Every variable referenced in your email template must be included as a key-value pair.\n" +
	"\n" +
	"Use these variables to insert custom information, such as a team name, URL or the user's employee ID. All variables are interpolated before the email is sent, regardless of the email provider.J0{\"custom_variable_key\": \"custom_variable_value\"}\xe0A\x01\xbaH\x05\x9a\x01\x02\x10\x1eR\x11templateVariables\x1aD\n" +
	"\x16TemplateVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\v\n" +
	"\t_templateB\x15\n" +
	"\x13_magiclink_auth_uriB\b\n" +
	"\x06_stateB\r\n" +
	"\v_expires_in\"\x9c\a\n" +
	"\x18SendPasswordlessResponse\x12\xc5\x01\n" +
	"\x0fauth_request_id\x18\x01 \x01(\tB\x9c\x01\x92A\x95\x012]Unique identifier for this passwordless authentication request. Use this ID to resend emails.J4\"h5Y8kT5RVwaea5WEgW4n-6C-aO_-fuTUW7Vb9-Rh3AcY9qxZqQ\"\xe0A\x03R\rauthRequestId\x12\xcc\x01\n" +
	"\n" +
	"expires_at\x18\x02 \x01(\x03B\xac\x01\x92A\xa5\x012\x96\x01Unix timestamp (seconds since epoch) when the passwordless authentication will expire. After this time, the OTP or magic link will no longer be valid.J\n" +
	"1748696575\xe0A\x03R\texpiresAt\x12\xbe\x01\n" +
	"\n" +
	"expires_in\x18\x03 \x01(\rB\x9e\x01\x92A\x97\x012\x8f\x01Number of seconds from now until the passwordless authentication expires. This is a convenience field calculated from the expires_at timestamp.J\x03300\xe0A\x03R\texpiresIn\x12\xa7\x02\n" +
	"\x11passwordless_type\x18\x04 \x01(\x0e2/.scalekit.v1.auth.passwordless.PasswordlessTypeB\xc8\x01\x92A\xbc\x012\xb2\x01Type of passwordless authentication that was sent via email. OTP sends a numeric code, LINK sends a clickable magic link, and LINK_OTP provides both options for user convenience.J\x05\"OTP\"\xbaH\x05\x82\x01\x02\x10\x01R\x10passwordlessType\"\xb4\x06\n" +
	"\x19VerifyPasswordLessRequest\x12\xbd\x01\n" +
	"\x04code\x18\x01 \x01(\tB\xa6\x01\x92A\x99\x012\x8c\x01The Verification Code (OTP) received via email. This is typically a 6-digit numeric code that users enter manually to verify their identity.J\b\"123456\"\xbaH\x06r\x04\x10\x01\x18\x14H\x00R\x04code\x12\x8a\x02\n" +
	"\n" +
	"link_token\x18\x02 \x01(\tB\xe8\x01\x92A\xdb\x012\xb0\x01The unique token from the magic link URL received via email. Extract this token when users click the magic link and are redirected to your application to later verify the user.J&\"afe9d61c-d80d-4020-a8ee-61765ab71cb3\"\xbaH\x06r\x04\x10\x01\x18dH\x00R\tlinkToken\x12\xa2\x02\n" +
	"\x0fauth_request_id\x18\x03 \x01(\tB\xf4\x01\x92A\xe8\x012\xaf\x01The authentication request identifier returned from the send passwordless email endpoint. Required when verifying OTP codes to link the verification with the original request.J4\"h5Y8kT5RVwaea5WEgW4n-6C-aO_-fuTUW7Vb9-Rh3AcY9qxZqQ\"\xbaH\x05r\x03\x18\xc8\x01H\x01R\rauthRequestId\x88\x01\x01B\x11\n" +
	"\x0fauth_credentialB\x12\n" +
	"\x10_auth_request_id\"\xc1\x02\n" +
	"\x19ResendPasswordlessRequest\x12\xa3\x02\n" +
	"\x0fauth_request_id\x18\x01 \x01(\tB\xfa\x01\x92A\xe9\x012\xb0\x01The authentication request identifier from the original send passwordless email request. Use this to resend the Verification Code (OTP) or Magic Link to the same email address.J4\"h5Y8kT5RVwaea5WEgW4n-6C-aO_-fuTUW7Vb9-Rh3AcY9qxZqQ\"\xbaH\n" +
	"\xc8\x01\x01r\x05\x10\x01\x18\xc8\x01R\rauthRequestId\"\x94\a\n" +
	"\x1aVerifyPasswordLessResponse\x12\xbc\x01\n" +
	"\x05email\x18\x01 \x01(\tB\xa5\x01\x92A\x9e\x012\x83\x01Email address of the successfully authenticated user. This confirms which email account was verified through the passwordless flow.J\x16\"john.doe@example.com\"\xe0A\x03R\x05email\x12\xe8\x01\n" +
	"\x05state\x18\x02 \x01(\tB\xcc\x01\x92A\xc5\x012\xad\x01The custom state parameter that was provided in the original authentication request, returned unchanged. Use this to restore your application's context after authentication.J\x13\"kdt7yiag28t341fr1\"\xe0A\x03H\x00R\x05state\x88\x01\x01\x12\xcb\x01\n" +
	"\btemplate\x18\x03 \x01(\x0e2+.scalekit.v1.auth.passwordless.TemplateTypeB}\x92Ar2fSpecifies which email template to choose. For User Signin choose SIGNIN and for User Signup use SIGNUPJ\b\"SIGNIN\"\xbaH\x05\x82\x01\x02\x10\x01H\x01R\btemplate\x88\x01\x01\x12\xe6\x01\n" +
	"\x11passwordless_type\x18\x04 \x01(\x0e2/.scalekit.v1.auth.passwordless.PasswordlessTypeB\x87\x01\x92A|2sThe type of passwordless authentication that was successfully verified, confirming which method the user completed.J\x05\"OTP\"\xbaH\x05\x82\x01\x02\x10\x01R\x10passwordlessTypeB\b\n" +
	"\x06_stateB\v\n" +
	"\t_template*7\n" +
	"\fTemplateType\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06SIGNIN\x10\x01\x12\n" +
	"\n" +
	"\x06SIGNUP\x10\x02*V\n" +
	"\x10PasswordlessType\x12!\n" +
	"\x1dPASSWORDLESS_TYPE_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03OTP\x10\x01\x12\b\n" +
	"\x04LINK\x10\x02\x12\f\n" +
	"\bLINK_OTP\x10\x032\xe9!\n" +
	"\x13PasswordlessService\x12\xdb\f\n" +
	"\x15SendPasswordlessEmail\x126.scalekit.v1.auth.passwordless.SendPasswordlessRequest\x1a7.scalekit.v1.auth.passwordless.SendPasswordlessResponse\"\xd0\v\x92A\x9c\v\n" +
	"\x11Passwordless Auth\x12\x17Send passwordless email\x1atSend a verification email containing either a verification code (OTP), magic link, or both to a user's email addressJ\xd0\x01\n" +
	"\x03200\x12\xc8\x01\n" +
	"\x8d\x01Successfully sent passwordless authentication email. Returns the authentication request details including expiration time and auth request ID\x126\n" +
	"4\x1a2#/definitions/passwordlessSendPasswordlessResponsej\xa4\b\n" +
	"\rx-codeSamples\x12\x92\b2\x8f\b\n" +
	"\xfc\x02*\xf9\x02\n" +
	"\x16\n" +
	"\x05label\x12\r\x1a\vNode.js SDK\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xc8\x02\n" +
	"\x06source\x12\xbd\x02\x1a\xba\x02const response = await scalekit.passwordless.\n" +
	"  sendPasswordlessEmail(\n" +
	"\t\"john.doe@example.com\",\n" +
	"\t{\n" +
	"\t\ttemplate: \"SIGNIN\",\n" +
	"\t\texpiresIn: 100,\n" +
	"\t\tmagiclinkAuthUri: \"https://www.google.com\",\n" +
	"\t\ttemplateVariables: {\n" +
	"\t\t\temployeeID: \"EMP523\",\n" +
	"\t\t\tteamName: \"Alpha Team\",\n" +
	"\t\t\tsupportEmail: \"support@yourcompany.com\",\n" +
	"\t\t},\n" +
	"\t}\n" +
	");\n" +
	"\x8d\x05*\x8a\x05\n" +
	"\x11\n" +
	"\x05label\x12\b\x1a\x06Go SDK\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xe6\x04\n" +
	"\x06source\x12\xdb\x04\x1a\xd8\x04templateType := scalekit.TemplateTypeSignin\n" +
	"response, err := client.Passwordless().SendPasswordlessEmail(\n" +
	"    ctx,\n" +
	"    \"john.doe@example.com\",\n" +
	"    &scalekit.SendPasswordlessOptions{\n" +
	"        Template:         &templateType,\n" +
	"        ExpiresIn:        100,\n" +
	"        MagiclinkAuthUri: \"https://www.google.com\",\n" +
	"        TemplateVariables: map[string]string{\n" +
	"            \"employeeID\":    \"EMP523\",\n" +
	"            \"teamName\":      \"Alpha Team\",\n" +
	"            \"supportEmail\":  \"support@yourcompany.com\",\n" +
	"        },\n" +
	"    },\n" +
	")\n" +
	"\n" +
	"if err != nil {\n" +
	"    // Handle error\n" +
	"    return\n" +
	"}\n" +
	"\n" +
	"authRequestId := response.AuthRequestId\x82\xb5\x18\x02\x18\x04\x82\xd3\xe4\x93\x02$:\x01*\"\x1f/api/v1/passwordless/email/send\x12\xbc\v\n" +
	"\x17VerifyPasswordlessEmail\x128.scalekit.v1.auth.passwordless.VerifyPasswordLessRequest\x1a9.scalekit.v1.auth.passwordless.VerifyPasswordLessResponse\"\xab\n" +
	"\x92A\xf5\t\n" +
	"\x11Passwordless Auth\x12\x19Verify passwordless email\x1aMVerify a user's identity using either a verification code or magic link tokenJ\x92\x01\n" +
	"\x03200\x12\x8a\x01\n" +
	"ISuccessfully verified the passwordless authentication. Returns user email\x12=\n" +
	";\x1a9.scalekit.v1.auth.passwordless.VerifyPasswordLessResponsej\xe0\a\n" +
	"\rx-codeSamples\x12\xce\a2\xcb\a\n" +
	"\xac\x02*\xa9\x02\n" +
	"\x16\n" +
	"\x05label\x12\r\x1a\vNode.js SDK\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xf8\x01\n" +
	"\x06source\x12\xed\x01\x1a\xea\x01const { authRequestId } = sendResponse;\n" +
	"const verifyResponse = await scalekit.passwordless.\n" +
	"  verifyPasswordlessEmail(\n" +
	"\t// Verification Code (OTP)\n" +
	"\t{ code: \"123456\" },\n" +
	"\t// Magic Link Token\n" +
	"\t{ linkToken: link_token },\n" +
	"\tauthRequestId\n" +
	");\n" +
	"\x99\x05*\x96\x05\n" +
	"\x11\n" +
	"\x05label\x12\b\x1a\x06Go SDK\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xf2\x04\n" +
	"\x06source\x12\xe7\x04\x1a\xe4\x04// Verify with OTP code\n" +
	"verifyResponse, err := client.Passwordless().VerifyPasswordlessEmail(\n" +
	"    ctx,\n" +
	"    &scalekit.VerifyPasswordlessOptions{\n" +
	"        Code:          \"123456\", // OTP code\n" +
	"        AuthRequestId: authRequestId,\n" +
	"    },\n" +
	")\n" +
	"\n" +
	"if err != nil {\n" +
	"    // Handle error\n" +
	"    return\n" +
	"}\n" +
	"\n" +
	"// Verify with magic link token\n" +
	"verifyResponse, err := client.Passwordless().VerifyPasswordlessEmail(\n" +
	"    ctx,\n" +
	"    &scalekit.VerifyPasswordlessOptions{\n" +
	"        LinkToken: linkToken, // Magic link token\n" +
	"    },\n" +
	")\n" +
	"\n" +
	"if err != nil {\n" +
	"    // Handle error\n" +
	"    return\n" +
	"}\n" +
	"\n" +
	"// User verified successfully\n" +
	"userEmail := verifyResponse.Email\x82\xb5\x18\x02\x18\x04\x82\xd3\xe4\x93\x02&:\x01*\"!/api/v1/passwordless/email/verify\x12\xd8\a\n" +
	"\x17ResendPasswordlessEmail\x128.scalekit.v1.auth.passwordless.ResendPasswordlessRequest\x1a7.scalekit.v1.auth.passwordless.SendPasswordlessResponse\"\xc9\x06\x92A\x93\x06\n" +
	"\x11Passwordless Auth\x12\x19Resend passwordless email\x1abResend a verification email if the user didn't receive it or if the previous code/link has expiredJ\xcb\x01\n" +
	"\x03200\x12\xc3\x01\n" +
	"\x83\x01Successfully resent the passwordless authentication email. Returns updated authentication request details with new expiration time.\x12;\n" +
	"9\x1a7.scalekit.v1.auth.passwordless.SendPasswordlessResponsej\xb0\x03\n" +
	"\rx-codeSamples\x12\x9e\x032\x9b\x03\n" +
	"\xcb\x01*\xc8\x01\n" +
	"\x16\n" +
	"\x05label\x12\r\x1a\vNode.js SDK\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x97\x01\n" +
	"\x06source\x12\x8c\x01\x1a\x89\x01const { authRequestId } = sendResponse;\n" +
	"const resendResponse = await scalekit.passwordless\n" +
	".resendPasswordlessEmail(\n" +
	"    authRequestId\n" +
	");\n" +
	"\xca\x01*\xc7\x01\n" +
	"\x11\n" +
	"\x05label\x12\b\x1a\x06Go SDK\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xa3\x01\n" +
	"\x06source\x12\x98\x01\x1a\x95\x01resendResponse, err := client.Passwordless().ResendPasswordlessEmail(\n" +
	"    ctx,\n" +
	"    authRequestId,\n" +
	")\n" +
	"\n" +
	"if err != nil {\n" +
	"    // Handle error\n" +
	"    return\n" +
	"}\x82\xb5\x18\x02\x18\x04\x82\xd3\xe4\x93\x02&:\x01*\"!/api/v1/passwordless/email/resend\x1a\xd9\x01\x92A\xd5\x01\n" +
	"\x11Passwordless Auth\x12\xbf\x01Endpoints for sending and verifying passwordless authentication emails. These APIs allow users to authenticate without passwords by receiving a verification code or magic link in their email.B\x94\x02\n" +
	"!com.scalekit.v1.auth.passwordlessB\x11PasswordlessProtoP\x01ZDgithub.com/scalekit-inc/scalekit-sdk-go/v2/pkg/grpc/scalekit/v1/auth\xa2\x02\x04SVAP\xaa\x02\x1dScalekit.V1.Auth.Passwordless\xca\x02\x1dScalekit\\V1\\Auth\\Passwordless\xe2\x02)Scalekit\\V1\\Auth\\Passwordless\\GPBMetadata\xea\x02 Scalekit::V1::Auth::Passwordlessb\x06proto3"

var (
	file_scalekit_v1_auth_passwordless_proto_rawDescOnce sync.Once
	file_scalekit_v1_auth_passwordless_proto_rawDescData []byte
)

func file_scalekit_v1_auth_passwordless_proto_rawDescGZIP() []byte {
	file_scalekit_v1_auth_passwordless_proto_rawDescOnce.Do(func() {
		file_scalekit_v1_auth_passwordless_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_scalekit_v1_auth_passwordless_proto_rawDesc), len(file_scalekit_v1_auth_passwordless_proto_rawDesc)))
	})
	return file_scalekit_v1_auth_passwordless_proto_rawDescData
}

var file_scalekit_v1_auth_passwordless_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_scalekit_v1_auth_passwordless_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_scalekit_v1_auth_passwordless_proto_goTypes = []any{
	(TemplateType)(0),                  // 0: scalekit.v1.auth.passwordless.TemplateType
	(PasswordlessType)(0),              // 1: scalekit.v1.auth.passwordless.PasswordlessType
	(*SendPasswordlessRequest)(nil),    // 2: scalekit.v1.auth.passwordless.SendPasswordlessRequest
	(*SendPasswordlessResponse)(nil),   // 3: scalekit.v1.auth.passwordless.SendPasswordlessResponse
	(*VerifyPasswordLessRequest)(nil),  // 4: scalekit.v1.auth.passwordless.VerifyPasswordLessRequest
	(*ResendPasswordlessRequest)(nil),  // 5: scalekit.v1.auth.passwordless.ResendPasswordlessRequest
	(*VerifyPasswordLessResponse)(nil), // 6: scalekit.v1.auth.passwordless.VerifyPasswordLessResponse
	nil,                                // 7: scalekit.v1.auth.passwordless.SendPasswordlessRequest.TemplateVariablesEntry
}
var file_scalekit_v1_auth_passwordless_proto_depIdxs = []int32{
	0, // 0: scalekit.v1.auth.passwordless.SendPasswordlessRequest.template:type_name -> scalekit.v1.auth.passwordless.TemplateType
	7, // 1: scalekit.v1.auth.passwordless.SendPasswordlessRequest.template_variables:type_name -> scalekit.v1.auth.passwordless.SendPasswordlessRequest.TemplateVariablesEntry
	1, // 2: scalekit.v1.auth.passwordless.SendPasswordlessResponse.passwordless_type:type_name -> scalekit.v1.auth.passwordless.PasswordlessType
	0, // 3: scalekit.v1.auth.passwordless.VerifyPasswordLessResponse.template:type_name -> scalekit.v1.auth.passwordless.TemplateType
	1, // 4: scalekit.v1.auth.passwordless.VerifyPasswordLessResponse.passwordless_type:type_name -> scalekit.v1.auth.passwordless.PasswordlessType
	2, // 5: scalekit.v1.auth.passwordless.PasswordlessService.SendPasswordlessEmail:input_type -> scalekit.v1.auth.passwordless.SendPasswordlessRequest
	4, // 6: scalekit.v1.auth.passwordless.PasswordlessService.VerifyPasswordlessEmail:input_type -> scalekit.v1.auth.passwordless.VerifyPasswordLessRequest
	5, // 7: scalekit.v1.auth.passwordless.PasswordlessService.ResendPasswordlessEmail:input_type -> scalekit.v1.auth.passwordless.ResendPasswordlessRequest
	3, // 8: scalekit.v1.auth.passwordless.PasswordlessService.SendPasswordlessEmail:output_type -> scalekit.v1.auth.passwordless.SendPasswordlessResponse
	6, // 9: scalekit.v1.auth.passwordless.PasswordlessService.VerifyPasswordlessEmail:output_type -> scalekit.v1.auth.passwordless.VerifyPasswordLessResponse
	3, // 10: scalekit.v1.auth.passwordless.PasswordlessService.ResendPasswordlessEmail:output_type -> scalekit.v1.auth.passwordless.SendPasswordlessResponse
	8, // [8:11] is the sub-list for method output_type
	5, // [5:8] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_scalekit_v1_auth_passwordless_proto_init() }
func file_scalekit_v1_auth_passwordless_proto_init() {
	if File_scalekit_v1_auth_passwordless_proto != nil {
		return
	}
	file_scalekit_v1_auth_passwordless_proto_msgTypes[0].OneofWrappers = []any{}
	file_scalekit_v1_auth_passwordless_proto_msgTypes[2].OneofWrappers = []any{
		(*VerifyPasswordLessRequest_Code)(nil),
		(*VerifyPasswordLessRequest_LinkToken)(nil),
	}
	file_scalekit_v1_auth_passwordless_proto_msgTypes[4].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_scalekit_v1_auth_passwordless_proto_rawDesc), len(file_scalekit_v1_auth_passwordless_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_scalekit_v1_auth_passwordless_proto_goTypes,
		DependencyIndexes: file_scalekit_v1_auth_passwordless_proto_depIdxs,
		EnumInfos:         file_scalekit_v1_auth_passwordless_proto_enumTypes,
		MessageInfos:      file_scalekit_v1_auth_passwordless_proto_msgTypes,
	}.Build()
	File_scalekit_v1_auth_passwordless_proto = out.File
	file_scalekit_v1_auth_passwordless_proto_goTypes = nil
	file_scalekit_v1_auth_passwordless_proto_depIdxs = nil
}
